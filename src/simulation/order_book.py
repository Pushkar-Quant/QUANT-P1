"""
High-performance Limit Order Book (LOB) implementation with L2 depth.

This module implements a realistic order book with:
- Price-time priority matching
- Queue position tracking
- Latency modeling
- Order lifecycle management
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from collections import defaultdict, deque
import numpy as np


class OrderType(Enum):
    """Order types supported by the LOB."""
    LIMIT = "limit"
    MARKET = "market"
    CANCEL = "cancel"


class OrderSide(Enum):
    """Order side: buy or sell."""
    BUY = "buy"
    SELL = "sell"


@dataclass
class Order:
    """Represents a single order in the book."""
    order_id: int
    side: OrderSide
    order_type: OrderType
    price: float
    size: int
    timestamp: float
    trader_id: str = "unknown"
    latency: float = 0.0  # Simulated network latency
    
    def __post_init__(self):
        """Validate order parameters with comprehensive edge case handling."""
        # Validate size (all orders need positive size, but it's ignored for CANCEL)
        if self.size <= 0:
            raise ValueError(f"Order size must be positive, got {self.size}")
        
        # Validate price for limit orders only
        if self.order_type == OrderType.LIMIT and self.price <= 0:
            raise ValueError(f"Limit order price must be positive, got {self.price}")
        
        # Timestamp must be non-negative
        if self.timestamp < 0:
            raise ValueError(f"Timestamp must be non-negative, got {self.timestamp}")
        
        # Latency must be non-negative
        if self.latency < 0:
            raise ValueError(f"Latency must be non-negative, got {self.latency}")


@dataclass
class Fill:
    """Represents an order fill event."""
    order_id: int
    price: float
    size: int
    timestamp: float
    aggressive_order_id: int
    passive_order_id: int
    side: OrderSide


@dataclass
class PriceLevel:
    """Represents a price level in the order book."""
    price: float
    orders: deque = field(default_factory=deque)  # FIFO queue
    total_size: int = 0
    
    def add_order(self, order: Order):
        """Add order to this price level."""
        self.orders.append(order)
        self.total_size += order.size
    
    def remove_order(self, order_id: int) -> Optional[Order]:
        """Remove order by ID from this level."""
        for i, order in enumerate(self.orders):
            if order.order_id == order_id:
                removed = self.orders[i]
                del self.orders[i]
                self.total_size -= removed.size
                return removed
        return None
    
    def get_queue_position(self, order_id: int) -> Optional[int]:
        """Get the queue position of an order (0-indexed)."""
        for i, order in enumerate(self.orders):
            if order.order_id == order_id:
                return i
        return None


class LimitOrderBook:
    """
    Event-driven Limit Order Book with realistic microstructure.
    
    Features:
    - Price-time priority
    - Queue position tracking
    - Market impact
    - Latency simulation
    """
    
    def __init__(self, tick_size: float = 0.01):
        self.tick_size = tick_size
        
        # Price levels: {price: PriceLevel}
        self.bids: Dict[float, PriceLevel] = {}
        self.asks: Dict[float, PriceLevel] = {}
        
        # Order tracking: {order_id: Order}
        self.orders: Dict[int, Order] = {}
        
        # Event log
        self.fills: List[Fill] = []
        self.cancellations: List[Tuple[int, float]] = []
        
        # Statistics
        self.total_volume = 0
        self.total_trades = 0
        self.current_time = 0.0
        
        # Order ID counter
        self._next_order_id = 1
    
    def get_next_order_id(self) -> int:
        """Generate unique order ID."""
        order_id = self._next_order_id
        self._next_order_id += 1
        return order_id
    
    def round_price(self, price: float) -> float:
        """Round price to tick size."""
        return round(price / self.tick_size) * self.tick_size
    
    def submit_order(self, order: Order) -> List[Fill]:
        """
        Submit an order to the book.
        
        Returns:
            List of fills generated by this order.
        """
        self.current_time = order.timestamp
        
        if order.order_type == OrderType.MARKET:
            return self._process_market_order(order)
        elif order.order_type == OrderType.LIMIT:
            return self._process_limit_order(order)
        elif order.order_type == OrderType.CANCEL:
            self._process_cancellation(order)
            return []
        else:
            raise ValueError(f"Unknown order type: {order.order_type}")
    
    def _process_market_order(self, order: Order) -> List[Fill]:
        """Process a market order (takes liquidity)."""
        fills = []
        remaining_size = order.size
        
        # Select appropriate side of book
        book_side = self.asks if order.side == OrderSide.BUY else self.bids
        
        if not book_side:
            return fills  # No liquidity available
        
        # Get sorted prices
        prices = sorted(book_side.keys()) if order.side == OrderSide.BUY else sorted(book_side.keys(), reverse=True)
        
        for price in prices:
            if remaining_size <= 0:
                break
            
            level = book_side[price]
            
            while level.orders and remaining_size > 0:
                passive_order = level.orders[0]
                fill_size = min(remaining_size, passive_order.size)
                
                # Create fill
                fill = Fill(
                    order_id=order.order_id,
                    price=price,
                    size=fill_size,
                    timestamp=self.current_time,
                    aggressive_order_id=order.order_id,
                    passive_order_id=passive_order.order_id,
                    side=order.side
                )
                fills.append(fill)
                
                # Update order
                passive_order.size -= fill_size
                level.total_size -= fill_size
                remaining_size -= fill_size
                self.total_volume += fill_size
                self.total_trades += 1
                
                # Remove if fully filled
                if passive_order.size == 0:
                    level.orders.popleft()
                    # Safe deletion - check if exists first
                    if passive_order.order_id in self.orders:
                        del self.orders[passive_order.order_id]
            
            # Clean up empty levels
            if level.total_size == 0:
                del book_side[price]
        
        self.fills.extend(fills)
        return fills
    
    def _process_limit_order(self, order: Order) -> List[Fill]:
        """Process a limit order (can take and/or provide liquidity)."""
        fills = []
        order.price = self.round_price(order.price)
        
        # Check if order crosses the spread (aggressive)
        if order.side == OrderSide.BUY:
            best_ask = self.get_best_ask()
            if best_ask is not None and order.price >= best_ask:
                # Create temporary market order for crossing part
                crossing_order = Order(
                    order_id=order.order_id,
                    side=order.side,
                    order_type=OrderType.MARKET,
                    price=0,
                    size=order.size,
                    timestamp=order.timestamp,
                    trader_id=order.trader_id,
                    latency=order.latency
                )
                fills = self._process_market_order(crossing_order)
                
                # Update remaining size
                filled_size = sum(f.size for f in fills)
                order.size -= filled_size
        else:
            best_bid = self.get_best_bid()
            if best_bid is not None and order.price <= best_bid:
                crossing_order = Order(
                    order_id=order.order_id,
                    side=order.side,
                    order_type=OrderType.MARKET,
                    price=0,
                    size=order.size,
                    timestamp=order.timestamp,
                    trader_id=order.trader_id,
                    latency=order.latency
                )
                fills = self._process_market_order(crossing_order)
                filled_size = sum(f.size for f in fills)
                order.size -= filled_size
        
        # Add remaining to book if any
        if order.size > 0:
            self._add_to_book(order)
        
        return fills
    
    def _add_to_book(self, order: Order):
        """Add order to the appropriate side of the book."""
        book_side = self.bids if order.side == OrderSide.BUY else self.asks
        
        if order.price not in book_side:
            book_side[order.price] = PriceLevel(price=order.price)
        
        book_side[order.price].add_order(order)
        self.orders[order.order_id] = order
    
    def _process_cancellation(self, cancel_order: Order):
        """Process order cancellation."""
        if cancel_order.order_id not in self.orders:
            return  # Order doesn't exist
        
        order = self.orders[cancel_order.order_id]
        book_side = self.bids if order.side == OrderSide.BUY else self.asks
        
        if order.price in book_side:
            level = book_side[order.price]
            removed = level.remove_order(cancel_order.order_id)
            
            if removed:
                # Safe deletion - check if exists first
                if cancel_order.order_id in self.orders:
                    del self.orders[cancel_order.order_id]
                self.cancellations.append((cancel_order.order_id, self.current_time))
                
                # Clean up empty levels
                if level.total_size == 0:
                    del book_side[order.price]
    
    def cancel_order(self, order_id: int) -> bool:
        """Cancel an order by ID."""
        if order_id not in self.orders:
            return False
        
        cancel = Order(
            order_id=order_id,
            side=OrderSide.BUY,  # Dummy value, not used
            order_type=OrderType.CANCEL,
            price=0,  # Not used for cancellations
            size=1,  # Placeholder (passes validation, ignored by LOB)
            timestamp=self.current_time
        )
        self._process_cancellation(cancel)
        return True
    
    def get_best_bid(self) -> Optional[float]:
        """Get best bid price."""
        return max(self.bids.keys()) if self.bids else None
    
    def get_best_ask(self) -> Optional[float]:
        """Get best ask price."""
        return min(self.asks.keys()) if self.asks else None
    
    def get_midprice(self) -> Optional[float]:
        """Get mid-price."""
        best_bid = self.get_best_bid()
        best_ask = self.get_best_ask()
        
        if best_bid is None or best_ask is None:
            return None
        
        return (best_bid + best_ask) / 2
    
    def get_spread(self) -> Optional[float]:
        """Get bid-ask spread."""
        best_bid = self.get_best_bid()
        best_ask = self.get_best_ask()
        
        if best_bid is None or best_ask is None:
            return None
        
        return best_ask - best_bid
    
    def get_book_depth(self, levels: int = 5) -> Dict:
        """
        Get L2 market depth.
        
        Returns:
            Dictionary with 'bids' and 'asks' lists of (price, size) tuples.
        """
        bid_prices = sorted(self.bids.keys(), reverse=True)[:levels]
        ask_prices = sorted(self.asks.keys())[:levels]
        
        return {
            'bids': [(p, self.bids[p].total_size) for p in bid_prices],
            'asks': [(p, self.asks[p].total_size) for p in ask_prices]
        }
    
    def get_order_book_imbalance(self, levels: int = 5) -> float:
        """
        Calculate order book imbalance.
        
        Returns:
            Imbalance in [-1, 1] where positive means more buying pressure.
        """
        depth = self.get_book_depth(levels)
        
        bid_volume = sum(size for _, size in depth['bids'])
        ask_volume = sum(size for _, size in depth['asks'])
        
        total = bid_volume + ask_volume
        if total == 0:
            return 0.0
        
        return (bid_volume - ask_volume) / total
    
    def get_queue_position(self, order_id: int) -> Optional[Tuple[int, int]]:
        """
        Get queue position for an order.
        
        Returns:
            (position, total_size_at_level) or None if order not found.
        """
        if order_id not in self.orders:
            return None
        
        order = self.orders[order_id]
        book_side = self.bids if order.side == OrderSide.BUY else self.asks
        
        if order.price not in book_side:
            return None
        
        level = book_side[order.price]
        position = level.get_queue_position(order_id)
        
        if position is None:
            return None
        
        return (position, level.total_size)
    
    def get_state_snapshot(self) -> Dict:
        """Get current state of the order book."""
        return {
            'timestamp': self.current_time,
            'best_bid': self.get_best_bid(),
            'best_ask': self.get_best_ask(),
            'midprice': self.get_midprice(),
            'spread': self.get_spread(),
            'imbalance': self.get_order_book_imbalance(),
            'depth': self.get_book_depth(levels=10),
            'total_volume': self.total_volume,
            'total_trades': self.total_trades,
            'num_bid_levels': len(self.bids),
            'num_ask_levels': len(self.asks)
        }
    
    def __repr__(self) -> str:
        """String representation of the order book."""
        best_bid = self.get_best_bid()
        best_ask = self.get_best_ask()
        midprice = self.get_midprice()
        spread = self.get_spread()
        
        return (f"LimitOrderBook(bid={best_bid:.2f}, ask={best_ask:.2f}, "
                f"mid={midprice:.2f}, spread={spread:.4f}, "
                f"trades={self.total_trades}, volume={self.total_volume})")
